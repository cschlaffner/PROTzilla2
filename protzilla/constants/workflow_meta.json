{
  "importing": {
    "ms_data_import": {
      "max_quant_import": {
        "name": "Max Quant",
        "description": "Max Quant Data Import",
        "parameters": {
          "file_path": {
            "name": "MaxQuant intensities file:",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "intensity parameter",
            "type": "categorical",
            "categories": [
              "LFQ intensity",
              "Intensity",
              "iBAQ"
            ],
            "default": "Intensity"
          }
        }
      },
      "ms_fragger_import": {
        "name": "MS Fragger",
        "description": "MS Fragger Data Import",
        "parameters": {
          "file_path": {
            "name": "MSFragger intensities file:",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "intensity name",
            "type": "categorical",
            "categories": [
              "Intensity",
              "MaxLFQ Total Intensity",
              "MaxLFQ Intensity",
              "Total Intensity",
              "MaxLFQ Unique Intensity",
              "Unique Spectral Count",
              "Unique Intensity",
              "Spectral Count",
              "Total Spectral Count"
            ],
            "default": "Intensity"
          }
        }
      }
    },
    "metadata_import": {
      "metadata_import_method": {
        "name": "Metadata Import",
        "description": "Import Metadata",
        "parameters": {
          "file_path": {
            "name": "Metadata file:",
            "type": "file",
            "default": null
          },
          "feature_orientation": {
            "name": "feature orientation",
            "type": "categorical",
            "categories": [
              "Rows (features in rows, samples in columns)",
              "Columns (samples in rows, features in columns)"
            ],
            "default": "Columns (samples in rows, features in columns)"
          }
        }
      }
    },
    "peptide_import": {
      "peptide_import": {
        "name": "Peptide Import",
        "description": "Import Peptide-Data",
        "parameters": {
          "file_path": {
            "name": "Peptide File",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "Intensity Parameter (same as MS-Data)",
            "type": "categorical",
            "categories": [
              "LFQ intensity",
              "Intensity",
              "iBAQ"
            ],
            "default": "Intensity"
          }
        }
      }
    }
  },
  "data_preprocessing": {
    "filter_proteins": {
      "samples_missing_filter": {
        "name": "Samples Missing",
        "description": "Filters all proteins that are contained in less than a set percentage of samples",
        "parameters": {
          "percentage": {
            "name": "Percentage of minimum non-missing samples per protein",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "filter_samples": {
      "protein_count_filter": {
        "name": "Protein Count",
        "description": "Filter by protein count per sample",
        "parameters": {
          "threshold": {
            "name": "Number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "proteins_missing_filter": {
        "name": "Proteins Missing",
        "description": "Filters all samples that contain less than a set percentage of proteins",
        "parameters": {
          "percentage": {
            "name": "Percentage of minimum non-missing proteins per sample",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "protein_intensity_sum_filter": {
        "name": "Sum of Intensities",
        "description": "Filter by sum of protein intensities per sample",
        "parameters": {
          "threshold": {
            "name": "Number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "outlier_detection": {
      "pca": {
        "name": "PCA",
        "description": "This function filters out outliers using a PCA based approach based geometrical distance to the median and returns a list of samples that are inliers. Allows 2D (using an ellipse) or 3D (using an ellipsoid) analysis.",
        "parameters": {
          "threshold": {
            "name": "Threshold for number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          },
          "number_of_components": {
            "name": "Number of components:",
            "type": "numeric",
            "min": 2,
            "max": 3,
            "step": 1,
            "default": 3
          }
        },
        "graphs": [
          {}
        ]
      },
      "isolation_forest": {
        "name": "Isolation Forest",
        "description": "This function filters out outliers using a clustering isolation forest approach.",
        "parameters": {
          "n_estimators": {
            "name": "Number of estimators:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 100
          }
        },
        "graphs": [
          {}
        ]
      },
      "local_outlier_factor": {
        "name": "Local Outlier Factor",
        "description": "This function filters out outliers using a clustering Local Outlier Factor approach based on k nearest neighbors clustering.",
        "parameters": {
          "number_of_neighbors": {
            "name": "Number of neighbours:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 20
          }
        },
        "graphs": [
          {}
        ]
      }
    },
    "transformation": {
      "log_transformation": {
        "name": "Log",
        "description": "This function log-transforms intensity DataFrames. Supports log-transformation to the base of 2 or 10.",
        "parameters": {
          "log_base": {
            "name": "Log transformation base:",
            "type": "categorical",
            "categories": [
              "log2",
              "log10"
            ],
            "default": "log2"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      }
    },
    "normalisation": {
      "z_score": {
        "name": "Z-Score",
        "description": "A function to run the sklearn StandardScaler class on your dataframe. Normalises the data on the level of each sample. Scales the data to zero mean and unit variance. This is often also called z-score normalisation/ transformation.",
        "parameters": {},
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "totalsum": {
        "name": "Total Sum",
        "description": "A function to perform normalisation using the total sum of sample intensities on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the total sum of sample intensities.",
        "parameters": {},
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "median": {
        "name": "Median",
        "description": "A function to perform a quartile/percentile normalisation on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the chosen intensity quartile of the respective sample. By default, the median (50%-quartile) is used.",
        "parameters": {
          "percentile": {
            "name": "Percentile for normalisation:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "ref_protein": {
        "name": "Protein Reference",
        "description": "A function to perform protein-intensity normalisation in reference to a selected protein on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the intensity of the chosen reference protein in each sample. Samples where this value is zero will be removed and returned separately.",
        "parameters": {
          "reference_protein": {
            "name": "Reference Protein:",
            "type": "text",
            "default": "",
            "placeholder": "Enter the protein ID for the reference protein"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      }
    },
    "imputation": {
      "min_value_per_dataset": {
        "name": "Min per Dataset",
        "description": "A function to impute missing values for each protein by taking into account data from the entire dataframe. Sets missing value to the smallest measured value in the dataframe. The user can also assign a shrinking factor to take a fraction of that minimum value for imputation.",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking Value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "min_value_per_protein": {
        "name": "Min per Protein",
        "description": "A function to impute missing values for each protein by taking into account data from each protein. Sets missing value to the smallest measured value for each protein column. The user can also assign a shrinking factor to take a fraction of that minimum value for imputation. CAVE: All proteins without any values will be filtered out.",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking Value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "min_value_per_sample": {
        "name": "Min per Sample",
        "description": "Sets missing intensity values to the smallest measured value for each sample",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking Value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "simple_imputation_per_protein": {
        "name": "SimpleImputer",
        "description": "Imputation methods include imputation by mean, median and mode. Implements the sklearn.SimpleImputer class",
        "parameters": {
          "strategy": {
            "name": "Strategy:",
            "type": "categorical",
            "categories": [
              "mean",
              "median",
              "most_frequent"
            ],
            "default": "mean"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "knn": {
        "name": "kNN",
        "description": "A function to perform value imputation based on KNN (k-nearest neighbors). Imputes missing values for each sample based on intensity-wise similar samples. Two samples are close if the features that neither is missing are close.",
        "parameters": {
          "number_of_neighbours": {
            "name": "Number of neighbours:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type - Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "filter_peptides": {
      "pep_filter": {
        "name": "PEP Threshold",
        "description": "Filter by PEP-Threshold",
        "parameters": {
          "threshold": {
            "name": "Threshold Value for PEP",
            "type": "numeric",
            "min": 0,
            "default": 0
          },
          "peptide_df": {
            "type": "empty",
            "name": "peptide_df"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Bar chart"
            }
          }
        ]
      }
    }
  },
  "data_analysis": {
    "differential_expression": {
      "anova": {
        "name": "ANOVA",
        "description": "A function that uses ANOVA to test the difference between two or more groups defined in the clinical data. The ANOVA test is conducted on the level of each protein. The p-values are corrected for multiple testing.",
        "parameters": {
          "intensity_df": {
            "name": "Input Dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple Testing Correction Method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error Rate (alpha)",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "grouping": {
            "name": "Grouping:",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "selected_groups"
            ],
            "categories": [],
            "default": "None"
          },
          "selected_groups": {
            "name": "Selected Groups:",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": "None",
            "multiple": true,
            "default_select_all": false
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "t_test": {
        "name": "t-Test",
        "description": "A function to conduct a two sample t-test between groups defined in the clinical data. The t-test is conducted on the level of each protein. The p-values are corrected for multiple testing.",
        "parameters": {
          "intensity_df": {
            "name": "Input Dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple Testing Correction Method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error Rate (alpha)",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "fc_threshold": {
            "name": "Fold change threshold",
            "type": "numeric",
            "min": 0,
            "default": 0
          },
          "log_base": {
            "name": "base of log transformation (leave empty if no log transformation was performed on the data)",
            "type": "numeric",
            "min": 2,
            "default": null
          },
          "grouping": {
            "name": "Grouping",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "group1",
              "group2"
            ],
            "categories": [],
            "default": null
          },
          "group1": {
            "name": "Group 1",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "group2": {
            "name": "Group 2",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "linear_model": {
        "name": "linear model",
        "description": "A function to fit a linear model using Ordinary Least Squares for each Protein. The linear model fits the protein intensities on Y axis and the grouping on X for group1 X=-1 and group2 X=1. The p-values are corrected for multiple testing.",
        "parameters": {
          "intensity_df": {
            "name": "Input Dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple Testing Correction Method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error Rate (alpha)",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "fc_threshold": {
            "name": "Fold change threshold",
            "type": "numeric",
            "min": 0,
            "default": 0
          },
          "grouping": {
            "name": "Grouping",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "group1",
              "group2"
            ],
            "categories": [],
            "default": null
          },
          "group1": {
            "name": "Group 1",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "group2": {
            "name": "Group 2",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      }
    },
    "plot": {
      "volcano": {
        "name": "Volcano Plot",
        "description": "",
        "parameters": {
          "p_values": {
            "name": "p-value df",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "log2_fc": {
            "name": "log2 fold change df",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "fc_threshold": {
            "name": "log2 fold change threshold",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "alpha": {
            "name": "alpha/corrected alpha",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "proteins_of_interest_input": {
            "name": "Proteins of Interest",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "proteins_of_interest"
            ]
          },
          "proteins_of_interest": {
            "type": "categorical",
            "fill": "protein_ids",
            "categories": [],
            "default": null,
            "multiple": true
          }
        }
      },
      "heatmap": {
        "name": "Heatmap",
        "description": "",
        "parameters": {}
      },
      "scatter_plot": {
        "name": "Scatter plot",
        "description": "Creates a scatter plot from data",
        "parameters": {
          "input_df": {
            "name": "Choose dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "color_df": {
            "name": "Choose a dataframe to assign color to marks (optional)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "optional": true
          }
        }
      },
      "clustergram": {
        "name": "Clustergram",
        "description": "Creates a clustergram from data",
        "parameters": {
          "input_df": {
            "name": "Input dataframe: choose dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "sample_group_df": {
            "name": "Grouping dataframe: choose a dataframe that assigns the samples present in the input dataframe to a group they belong (optional)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "optional": true
          },
          "flip_axes": {
            "name": "Do you want to flip the orientation of the heatmap's axes?",
            "type": "categorical",
            "categories": [
              "yes",
              "no"
            ],
            "default": "no"
          }
        }
      },
      "precision_recall_curve": {
        "name": "Precision recall curve",
        "description": "The precision-recall curve shows the tradeoff between precision and recall for different threshold",
        "parameters": {
          "model": {
            "name": "Choose trained model",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "input_test_df": {
            "name": "Choose test data",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_test_df": {
            "name": "Choose labels for test data",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "plot_title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          }
        }
      },
      "roc_curve": {
        "name": "ROC curve",
        "description": "The ROC curve helps assess the model's ability to discriminate between positive and negative classes and determine an optimal threshold for decision making",
        "parameters": {
          "model": {
            "name": "Choose trained model",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "input_test_df": {
            "name": "Choose test data",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_test_df": {
            "name": "Choose labels for test data",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "plot_title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          }
        }
      }
    },
    "clustering": {
      "k_means": {
        "name": "K-Means",
        "description": "Partitions a number of samples in k clusters using k-means",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "dynamic": true
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "multiple": true
          },
          "n_clusters": {
            "name": "Number of clusters to find",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 8,
            "multiple": true
          },
          "random_state": {
            "name": "Seed for centroid initialisation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6,
            "multiple": true
          },
          "init_centroid_strategy": {
            "name": "Method for initialisation of centroids",
            "type": "categorical",
            "categories": [
              "k-means++",
              "random"
            ],
            "default": "random",
            "multiple": true
          },
          "n_init": {
            "name": "Number of times the k-means algorithm is run with different centroid seeds",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 10,
            "multiple": true
          },
          "max_iter": {
            "name": "Maximum number of iterations of the k-means algorithm for a single run.",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 300,
            "multiple": true
          },
          "tolerance": {
            "name": "Relative tolerance with regards to Frobenius norm",
            "type": "numeric",
            "min": 0,
            "default": 1e-4,
            "multiple": true
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "expectation_maximisation": {
        "name": "Expectation-maximization (EM) algorithm for fitting mixture-of-Gaussian models",
        "description": "",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "dynamic": true
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "multiple": true
          },
          "n_components": {
            "name": "The number of mixture components",
            "type": "numeric",
            "default": 1,
            "multiple": true
          },
          "reg_covar": {
            "name": "Non-negative regularization added to the diagonal of covariance",
            "type": "numeric",
            "default": 1e-6,
            "multiple": true
          },
          "covariance_type": {
            "name": "Type of covariance",
            "type": "categorical",
            "categories": [
              "full",
              "tied",
              "diag",
              "spherical"
            ],
            "default": "full",
            "multiple": true
          },
          "init_params": {
            "name": "The method used to initialize the weights, the means and the precisions.",
            "type": "categorical",
            "categories": [
              "kmeans",
              "k-means++",
              "random",
              "random_from_data"
            ],
            "default": "kmeans",
            "multiple": true
          },
          "max_iter": {
            "name": "The number of iterations tu perform",
            "type": "numeric",
            "default": 100,
            "multiple": true
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "hierarchical_agglomerative_clustering": {
        "name": "Hierarchical agglomerative clustering",
        "description": "Performs hierarchical clustering utilizing a bottom-up approach",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "dynamic": true
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "multiple": true
          },
          "n_clusters": {
            "name": "Number of clusters to find",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 2,
            "multiple": true
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean",
              "manhattan",
              "cosine",
              "l1",
              "l2"
            ],
            "default": "euclidean",
            "multiple": true
          },
          "linkage": {
            "name": "The linkage criterion to use in order to to determine the distance to use between sets of observation",
            "type": "categorical",
            "categories": [
              "ward",
              "complete",
              "average",
              "single"
            ],
            "default": "ward",
            "multiple": true
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      }
    },
    "classification": {
      "random_forest": {
        "name": "Random Forest",
        "description": "A random forest is a meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "test_size": {
            "name": "Test size",
            "type": "numeric",
            "default": 0.20
          },
          "split_stratify": {
            "name": "Split data in a stratified fashion",
            "type": "categorical",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes"
          },
          "validation_strategy": {
            "name": "Validation Strategy",
            "type": "categorical_dynamic",
            "categories": [
              "K-Fold",
              "Repeated K-Fold",
              "Stratified K-Fold",
              "Leave one out",
              "Leave p out",
              "Manual"
            ],
            "default": "K-Fold",
            "dynamic_parameters": {
              "K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Stratified K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Repeated K-Fold": [
                "n_splits",
                "n_repeats",
                "random_state_cv"
              ],
              "Leave p out": [
                "p_samples"
              ],
              "Manual": [
                "train_val_split"
              ]
            }
          },
          "train_val_split": {
            "name": "Choose the size of the validation data set (you can either enter the absolute number of validation samples or a number between 0.0 and 1.0 to represent the percentage of validation samples)",
            "type": "numeric",
            "dynamic": true,
            "default": 0.20
          },
          "n_splits": {
            "name": "Number of folds",
            "type": "numeric",
            "min": 2,
            "dynamic": true,
            "default": 5
          },
          "shuffle": {
            "name": "Whether to shuffle the data before splitting into batches",
            "type": "categorical_dynamic",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes",
            "dynamic": true,
            "dynamic_parameters": {
              "yes": [
                "random_state_cv"
              ]
            }
          },
          "n_repeats": {
            "name": "Number of times cross-validator needs to be repeated",
            "type": "numeric",
            "dynamic": true,
            "default": 10
          },
          "random_state_cv": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 42,
            "dynamic": true
          },
          "p_samples": {
            "name": "Size of the test sets",
            "type": "numeric",
            "dynamic": true,
            "default": 1
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "multiple": true
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "dynamic": true
          },
          "n_estimators": {
            "name": "The number of trees in the forest.",
            "type": "numeric",
            "default": 100,
            "multiple": true
          },
          "criterion": {
            "name": "The function to measure the quality of a split",
            "type": "categorical",
            "categories": [
              "gini",
              "log_loss",
              "entropy"
            ],
            "default": "gini",
            "multiple": true
          },
          "max_depth": {
            "name": "The maximum depth of the tree.",
            "type": "numeric",
            "default": 1,
            "multiple": true
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "svm": {
        "name": "Support Vector Machine (SVM)",
        "description": "",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_columns",
            "categories": [],
            "default": null
          },
          "test_size": {
            "name": "Test size",
            "type": "numeric",
            "default": 0.20
          },
          "split_stratify": {
            "name": "Split data in a stratified fashion",
            "type": "categorical",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes"
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "validation_strategy": {
            "name": "Validation Strategy",
            "type": "categorical_dynamic",
            "categories": [
              "K-Fold",
              "Repeated K-Fold",
              "Stratified K-Fold",
              "Leave one out",
              "Leave p out",
              "Manual"
            ],
            "default": "K-Fold",
            "dynamic_parameters": {
              "K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Stratified K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Repeated K-Fold": [
                "n_splits",
                "n_repeats",
                "random_state_cv"
              ],
              "Leave p out": [
                "p_samples"
              ],
              "Manual": [
                "test_size"
              ]
            }
          },
          "train_val_split": {
            "name": "Choose the size of the validation data set (you can either enter the absolute number of validation samples or a number between 0.0 and 1.0 to represent the percentage of validation samples)",
            "type": "numeric",
            "dynamic": true,
            "default": 0.20
          },
          "n_splits": {
            "name": "Number of folds",
            "type": "numeric",
            "min": 2,
            "dynamic": true,
            "default": 5
          },
          "shuffle": {
            "name": "Whether to shuffle the data before splitting into batches",
            "type": "categorical_dynamic",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes",
            "dynamic": true,
            "dynamic_parameters": {
              "True": [
                "random_state_cv"
              ]
            }
          },
          "n_repeats": {
            "name": "Number of times cross-validator needs to be repeated",
            "type": "numeric",
            "dynamic": true,
            "default": 10
          },
          "random_state_cv": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 42,
            "dynamic": true
          },
          "p_samples": {
            "name": "Size of the test sets",
            "type": "numeric",
            "dynamic": true,
            "default": 1
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "multiple": true
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "dynamic": true
          },
          "C": {
            "name": "C: Regularization parameter (the strength of the regularization is inversely proportional to C)",
            "type": "numeric",
            "min": 0.0,
            "default": 1.0,
            "multiple": true
          },
          "kernel": {
            "name": "Kernel type",
            "type": "categorical",
            "categories": [
              "linear",
              "poly",
              "rbf",
              "sigmoid",
              "precomputed"
            ],
            "default": "linear",
            "multiple": true
          },
          "tolerance": {
            "name": "Tolerance for stopping criterion",
            "type": "numeric",
            "min": 0,
            "default": 1e-4
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      }
    },
    "model_evaluation": {
      "evaluate_classification_model": {
        "name": "Evaluation of classification models",
        "description": "Assessing an already trained classification model on separate testing data using widely used scoring metrics",
        "parameters": {
          "model": {
            "name": "Choose trained model",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "input_test_df": {
            "name": "Choose testing data",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_test_df": {
            "name": "Choose labels for input data",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "scoring": {
            "name": "Choose metric to measure the model's performance",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "multiple": true
          }
        }
      }
    },
    "dimension_reduction": {
      "t_sne": {
        "name": "t-SNE",
        "description": "Dimension reduction of a dataframe using t-SNE",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "n_components": {
            "name": "Dimension of the embedded space",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 2
          },
          "perplexity": {
            "name": "Perplexity",
            "type": "numeric",
            "min": 5.0,
            "max": 50.0,
            "default": 30.0
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean",
              "manhattan",
              "cosine",
              "haversine"
            ],
            "default": "euclidean"
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "n_iter": {
            "name": "Maximum number of iterations for the optimization",
            "type": "numeric",
            "min": 250,
            "step": 1,
            "default": 1000
          },
          "n_iter_without_progress": {
            "name": "Maximum number of iterations without progress before aborting the optimization ",
            "type": "numeric",
            "min": 250,
            "step": 1,
            "default": 300
          }
        }
      },
      "umap": {
        "name": "UMAP",
        "description": "Dimension reduction of a dataframe using UMAP",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "n_neighbors": {
            "name": "Number of neighbors",
            "type": "numeric",
            "min": 2,
            "max": 100,
            "step": 1,
            "default": 15
          },
          "n_components": {
            "name": "Number of components",
            "type": "numeric",
            "min": 2,
            "max": 100,
            "step": 1,
            "default": 2
          },
          "min_dist": {
            "name": "The effective minimum distance between embedded points.",
            "type": "numeric",
            "min": 0.1,
            "default": 0.1
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean",
              "manhattan",
              "cosine",
              "haversine"
            ],
            "default": "euclidean"
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 42
          }
        }
      }
    }
  },
  "data_integration": {
    "enrichment_analysis": {
      "go_analysis_with_STRING": {
        "name": "GO Analysis with STRING",
        "description": "Online GO Analysis using STRING API",
        "parameters": {
          "proteins": {
            "name": "Dataframe with Protein IDs and direction of expression change column (e.g. log2FC)",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "protein_set_dbs": {
            "name": "Protein Set Libraries",
            "type": "categorical",
            "fill": "dbs_restring",
            "categories": [],
            "default": null,
            "multiple": true
          },
          "organism": {
            "name": "Organism / NCBI taxon identifiers (e.g. Human is 9606)",
            "type": "numeric",
            "default": 9606
          },
          "direction": {
            "name": "Direction of the analysis",
            "type": "categorical",
            "categories": [
              "both",
              "up",
              "down"
            ],
            "default": "both"
          },
          "background": {
            "name": "Background set (no upload = entire proteome)",
            "type": "file",
            "default": null
          }
        }
      },
      "go_analysis_with_enrichr": {
        "name": "GO Analysis with Enrichr",
        "description": "Online GO Analysis using Enrichr API",
        "parameters": {
          "proteins": {
            "name": "Dataframe with Protein IDs and direction of expression change column (e.g. log2FC)",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "protein_sets": {
            "name": "Protein Sets",
            "type": "categorical",
            "fill": "dbs_gseapy",
            "categories": [],
            "default": null,
            "multiple": true
          },
          "organism": {
            "name": "Enrichr supported organism",
            "type": "categorical",
            "categories": [
              "human",
              "mouse",
              "yeast",
              "fly",
              "fish",
              "worm"
            ],
            "default": "human"
          }
        }
      },
      "go_analysis_offline": {
        "name": "GO Analysis offline",
        "description": "Offline GO Analysis using a hypergeometric test",
        "parameters": {
          "proteins": {
            "name": "Dataframe with Protein IDs and direction of expression change column (e.g. log2FC)",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "protein_sets_path": {
            "name": "Upload Protein Sets with UniProt IDs (any of the following file types: .gmt, .txt, .csv, .json | .txt (one set per line): SetName: Protein1, Protein2, ... | .csv (one set per line): SetName, Protein1, Protein2, ... | .json: {SetName: [Protein1, Protein2, ...], SetName2: [Protein2, Protein3, ...]})",
            "type": "file",
            "default": null
          },
          "background": {
            "name": "Background set with UniProt IDs (one protein per line, csv or txt or no upload -> all proteins from protein sets)",
            "type": "file",
            "default": null
          }
        }
      },
      "gsea": {
        "name": "GSEA",
        "description": "Perform Gene Set Enrichment Analysis",
        "parameters": {
          "protein_df": {
            "name": "Dataframe with Protein IDs, Samples and intensities",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "gene_sets_field": {
            "name": "How do you want to provide the gene sets? (reselect to show dynamic fields)",
            "type": "categorical_dynamic",
            "categories": [
              "Upload a file",
              "Choose from Enrichr Options"
            ],
            "default": "Choose from Enrichr Options",
            "dynamic_parameters": {
              "Upload a file": [
                "gene_sets_path"
              ],
              "Choose from Enrichr Options": [
                "gene_sets_enrichr"
              ]
            }
          },
          "gene_sets_path": {
            "name": "Upload Gene Sets with uppercase Gene Symbols (any of the following file types: .gmt, .txt, .csv, .json | .txt (one set per line): SetName: Gene1, Gene2, ... | .csv (one set per line): SetName, Gene1, Gene2, ... | .json: {SetName: [Gene1, Gene2, ...], SetName2: [Gene2, Gene3, ...]})",
            "type": "file",
            "default": null,
            "dynamic": true
          },
          "gene_sets_enrichr": {
            "name": "Gene Sets",
            "type": "categorical",
            "fill": "dbs_gseapy",
            "categories": [],
            "default": null,
            "multiple": true,
            "dynamic": true
          },
          "grouping": {
            "name": "Grouping for Samples",
            "type": "categorical",
            "fill": "metadata_columns",
            "default": null
          },
          "min_size": {
            "name": "Minimum number of genes from gene set also in data",
            "type": "numeric",
            "default": 15
          },
          "max_size": {
            "name": "Maximum number of genes from gene set also in data",
            "type": "numeric",
            "default": 500
          },
          "number_of_permutations": {
            "name": "Number of permutations",
            "type": "numeric",
            "default": 1000
          },
          "permutation_type": {
            "name": "Permutation type (if samples >=15 set to phenotype)",
            "type": "categorical",
            "categories": [
              "phenotype",
              "gene_set"
            ],
            "default": "phenotype"
          },
          "ranking_method": {
            "name": "Method to calculate correlation or ranking",
            "type": "categorical",
            "categories": [
              "log2_ratio_of_classes",
              "signal_to_noise",
              "t_test",
              "ratio_of_classes",
              "diff_of_classes"
            ],
            "default": "signal_to_noise"
          },
          "weighted_score": {
            "name": "Weighted score for the enrichment score calculation, recommended values: 0, 1, 1.5 or 2",
            "type": "numeric",
            "default": 1
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "gsea_preranked": {
        "name": "GSEA Preranked",
        "description": "Maps proteins to genes and performs GSEA according using provided numerical column for ranking",
        "parameters": {
          "protein_df": {
            "name": "Dataframe with Protein IDs and a column to use for ranking (e.g. p values)",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "ranking_direction": {
            "name": "Sort the ranking column (ascending - smaller values are better, descending - larger values are better)",
            "type": "categorical",
            "categories": [
              "ascending",
              "descending"
            ],
            "default": "ascending"
          },
          "gene_sets_field": {
            "name": "How do you want to provide the gene sets? (reselect to show dynamic fields)",
            "type": "categorical_dynamic",
            "categories": [
              "Upload a file",
              "Choose from Enrichr Options"
            ],
            "default": "euclidean",
            "dynamic_parameters": {
              "Upload a file": [
                "gene_sets_path"
              ],
              "Choose from Enrichr Options": [
                "gene_sets_enrichr"
              ]
            }
          },
          "gene_sets_path": {
            "name": "Upload Gene Sets with Uppercase Gene Symbols (any of the following file types: .gmt, .txt, .csv, .json | .txt (one set per line): SetName: Gene1, Gene2, ... | .csv (one set per line): SetName, Gene1, Gene2, ... | .json: {SetName: [Gene1, Gene2, ...], SetName2: [Gene2, Gene3, ...]})",
            "type": "file",
            "default": null,
            "dynamic": true
          },
          "gene_sets_enrichr": {
            "name": "Gene Set Libraries",
            "type": "categorical",
            "fill": "dbs_gseapy",
            "categories": [],
            "default": null,
            "multiple": true,
            "dynamic": true
          },
          "min_size": {
            "name": "Minimum number of genes from gene set also in data",
            "type": "numeric",
            "default": 15
          },
          "max_size": {
            "name": "Maximum number of genes from gene set also in data",
            "type": "numeric",
            "default": 500
          },
          "number_of_permutations": {
            "name": "Number of permutations",
            "type": "numeric",
            "default": 1000
          },
          "permutation_type": {
            "name": "Permutation type (if samples >=15 set to phenotype)",
            "type": "categorical",
            "categories": [
              "phenotype",
              "gene_set"
            ],
            "default": "phenotype"
          },
          "weighted_score": {
            "name": "Weighted score for the enrichment score calculation, recommended values: 0, 1, 1.5 or 2",
            "type": "numeric",
            "default": 1
          }
        }
      }
    },
    "database_integration": {
      "uniprot": {
        "name": "Uniprot",
        "description": "Add Uniprot data to a dataframe",
        "parameters": {
          "dataframe": {
            "name": "Dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "database_name": {
            "name": "Database Name",
            "type": "categorical",
            "fill": "uniprot_databases",
            "fill_dynamic": [
              "fields"
            ]
          },
          "fields": {
            "name": "Fields",
            "type": "categorical",
            "multiple": true,
            "fill": "uniprot_fields"
          }
        }
      }
    },
    "plot": {
      "go_enrichment_bar_plot": {
        "name": "Bar plot for GO enrichment analysis",
        "description": "Creates a bar plot from GO enrichment data",
        "parameters": {
          "input_df": {
            "name": "Choose dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "categories"
            ]
          },
          "categories": {
            "name": "Categories/Sets to be plotted",
            "type": "categorical",
            "multiple": true,
            "fill": "enrichment_categories"
          },
          "value": {
            "name": "Value (bars will be plotted as -log10(value)), fdr only for GO Analysis with STRING, p_value is adjusted if available",
            "type": "categorical",
            "categories": [
              "p_value",
              "fdr"
            ],
            "default": "p_value"
          },
          "top_terms": {
            "name": "Number of top enriched terms per category",
            "type": "numeric",
            "min": 1,
            "max": 100,
            "step": 1,
            "default": 10
          },
          "cutoff": {
            "name": "Only terms with Adjusted P-value (or FDR) < cutoff will be shown",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          },
          "colors": {
            "name": "Colors for the plot (optional)",
            "type": "categorical",
            "multiple": true,
            "fill": "matplotlib_colors",
            "default": null
          }
        }
      },
      "go_enrichment_dot_plot": {
        "name": "Dot plot for GO enrichment analysis (offline & with Enrichr) ",
        "description": "Creates a categorical scatter plot from GO enrichment data",
        "parameters": {
          "input_df": {
            "name": "Choose enrichment dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "categories"
            ]
          },
          "x_axis_type": {
            "name": "Variable for x-axis: categorical scatter plot for one or multiple gene sets, or display combined score for one gene set",
            "type": "categorical",
            "categories": [
              "Gene Sets",
              "Combined Score"
            ],
            "default": "Gene Sets"
          },
          "categories": {
            "name": "Categories/Sets to be plotted (if this is empty, try reselecting 'results' from your chosen input)",
            "type": "categorical",
            "multiple": true,
            "fill": "enrichment_categories"
          },
          "top_terms": {
            "name": "Number of top enriched terms per category",
            "type": "numeric",
            "min": 1,
            "max": 100,
            "step": 1,
            "default": 5
          },
          "cutoff": {
            "name": "Only terms with Adjusted P-value < cutoff will be shown",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          },
          "rotate_x_labels": {
            "name": "Rotate x-axis labels (if multiple categories are selected)",
            "type": "boolean",
            "default": true
          },
          "show_ring": {
            "name": "Show ring around the dots",
            "type": "boolean",
            "default": false
          },
          "dot_size": {
            "name": "Scale the size of the dots",
            "type": "numeric",
            "default": 5
          }
        }
      }
    }
  }
}