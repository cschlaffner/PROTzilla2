{
  "importing": {
    "ms_data_import": {
      "max_quant_import": {
        "name": "MaxQuant",
        "description": "MaxQuant data import",
        "parameters": {
          "file_path": {
            "name": "MaxQuant intensities file:",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "Intensity parameter",
            "type": "categorical",
            "categories": [
              "LFQ intensity",
              "Intensity",
              "iBAQ"
            ],
            "default": "Intensity"
          },
          "map_to_uniprot": {
            "name": "Map to Uniprot IDs using Biomart (online)",
            "type": "boolean",
            "default": false
          }
        }
      },
      "diann_import": {
        "name": "DIA-NN",
        "description": "DIA-NN data import",
        "parameters": {
          "file_path": {
            "name": "DIA-NN intensities file:",
            "type": "file",
            "default": null
          },
          "map_to_uniprot": {
            "name": "Map to Uniprot IDs using Biomart (online)",
            "type": "boolean",
            "default": false
          }
        }
      },
      "ms_fragger_import": {
        "name": "MS Fragger",
        "description": "MS Fragger data import",
        "parameters": {
          "file_path": {
            "name": "MSFragger intensities file:",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "intensity name",
            "type": "categorical",
            "categories": [
              "Intensity",
              "MaxLFQ Total Intensity",
              "MaxLFQ Intensity",
              "Total Intensity",
              "MaxLFQ Unique Intensity",
              "Unique Spectral Count",
              "Unique Intensity",
              "Spectral Count",
              "Total Spectral Count"
            ],
            "default": "Intensity"
          },
          "map_to_uniprot": {
            "name": "Map to Uniprot IDs using Biomart (online)",
            "type": "boolean",
            "default": false
          }
        }
      }
    },
    "metadata_import": {
      "metadata_import_method": {
        "name": "Metadata import",
        "description": "Import metadata",
        "parameters": {
          "file_path": {
            "name": "Metadata file:",
            "type": "file",
            "default": null
          },
          "feature_orientation": {
            "name": "Feature orientation",
            "type": "categorical",
            "categories": [
              "Rows (features in rows, samples in columns)",
              "Columns (samples in rows, features in columns)"
            ],
            "default": "Columns (samples in rows, features in columns)"
          }
        }
      },
      "metadata_import_method_diann": {
        "name": "Metadata import DIA-NN",
        "description": "Import metadata for run relationships of DIA-NN",
        "parameters": {
          "file_path": {
            "name": "Run-Relationship metadata file:",
            "type": "file",
            "default": null
          },
          "groupby_sample": {
            "name": "Group replicate runs by sample using median",
            "type": "boolean",
            "default": false
          }
        }
      },
      "metadata_column_assignment": {
        "name": "Metadata column assignment",
        "description": "Assign columns to metadata categories, repeatable for each category",
        "parameters": {
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          },
          "metadata_required_column": {
            "name": "Missing, but required metadata columns",
            "fill": "metadata_required_columns",
            "type": "categorical",
            "categories": [],
            "default": null
          },
          "metadata_unknown_column": {
            "name": "Existing, but unknown metadata columns",
            "fill": "metadata_unknown_columns",
            "type": "categorical",
            "categories": [],
            "default": null
          }
        }
      }
    },
    "peptide_import": {
      "peptide_import": {
        "name": "Peptide import",
        "description": "Import peptide data",
        "parameters": {
          "file_path": {
            "name": "Peptide file",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "Intensity parameter (same as MS-Data)",
            "type": "categorical",
            "categories": [
              "LFQ intensity",
              "Intensity",
              "iBAQ"
            ],
            "default": "Intensity"
          }
        }
      }
    }
  },
  "data_preprocessing": {
    "filter_proteins": {
      "samples_missing_filter": {
        "name": "Samples missing",
        "description": "Filters all proteins that are contained in less than a set percentage of samples",
        "parameters": {
          "percentage": {
            "name": "Percentage of minimum non-missing samples per protein",
            "type": "numeric",
            "min": 0,
            "step": 0.1,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "filter_samples": {
      "protein_count_filter": {
        "name": "Protein Count",
        "description": "Filter by protein count per sample",
        "parameters": {
          "deviation_threshold": {
            "name": "Number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "proteins_missing_filter": {
        "name": "Proteins missing",
        "description": "Filters all samples that contain less than a set percentage of proteins",
        "parameters": {
          "percentage": {
            "name": "Percentage of minimum non-missing proteins per sample",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "protein_intensity_sum_filter": {
        "name": "Sum of intensities",
        "description": "Filter by sum of protein intensities per sample",
        "parameters": {
          "deviation_threshold": {
            "name": "Number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "outlier_detection": {
      "pca": {
        "name": "PCA",
        "description": "This function filters out outliers using a PCA based approach based geometrical distance to the median and returns a list of samples that are inliers. Allows 2D (using an ellipse) or 3D (using an ellipsoid) analysis.",
        "parameters": {
          "threshold": {
            "name": "Threshold for number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          },
          "number_of_components": {
            "name": "Number of components:",
            "type": "numeric",
            "min": 2,
            "max": 3,
            "step": 1,
            "default": 3
          }
        },
        "graphs": [
          {}
        ]
      },
      "isolation_forest": {
        "name": "Isolation forest",
        "description": "This function filters out outliers using a clustering isolation forest approach.",
        "parameters": {
          "n_estimators": {
            "name": "Number of estimators:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 100
          }
        },
        "graphs": [
          {}
        ]
      },
      "local_outlier_factor": {
        "name": "Local outlier factor",
        "description": "This function filters out outliers using a clustering Local Outlier Factor approach based on k nearest neighbors clustering.",
        "parameters": {
          "number_of_neighbors": {
            "name": "Number of neighbours:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 20
          }
        },
        "graphs": [
          {}
        ]
      }
    },
    "transformation": {
      "log_transformation": {
        "name": "Log",
        "description": "This function log-transforms intensity DataFrames. Supports log-transformation to the base of 2 or 10.",
        "parameters": {
          "log_base": {
            "name": "Log transformation base:",
            "type": "categorical",
            "categories": [
              "log2",
              "log10"
            ],
            "default": "log2"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      }
    },
    "normalisation": {
      "z_score": {
        "name": "Z-Score",
        "description": "A function to run the sklearn StandardScaler class on your dataframe. Normalises the data on the level of each sample. Scales the data to zero mean and unit variance. This is often also called z-score normalisation/ transformation.",
        "parameters": {},
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "totalsum": {
        "name": "Total sum",
        "description": "A function to perform normalisation using the total sum of sample intensities on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the total sum of sample intensities.",
        "parameters": {},
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "median": {
        "name": "Median",
        "description": "A function to perform a quartile/percentile normalisation on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the chosen intensity quartile of the respective sample. By default, the median (50%-quartile) is used.",
        "parameters": {
          "percentile": {
            "name": "Percentile for normalisation:",
            "type": "numeric",
            "min": 0,
            "step": 0.1,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "ref_protein": {
        "name": "Protein reference",
        "description": "A function to perform protein-intensity normalisation in reference to a selected protein on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the intensity of the chosen reference protein in each sample. Samples where this value is zero will be removed and returned separately.",
        "parameters": {
          "reference_protein": {
            "name": "Reference Protein:",
            "type": "text",
            "default": "",
            "placeholder": "Enter the protein ID for the reference protein"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      }
    },
    "imputation": {
      "min_value_per_dataset": {
        "name": "Min per dataset",
        "description": "A function to impute missing values for each protein by taking into account data from the entire dataframe. Sets missing value to the smallest measured value in the dataframe. The user can also assign a shrinking factor to take a fraction of that minimum value for imputation.",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            },
            "visual_transformation": {
              "name": "Visual transformation:",
              "type": "categorical",
              "categories": [
                "linear",
                "log10"
              ],
              "default": "log10"
            }
          },
          {
            "graph_type_quantities": {
              "name": "Graph type - imputed values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "min_value_per_protein": {
        "name": "Min per protein",
        "description": "A function to impute missing values for each protein by taking into account data from each protein. Sets missing value to the smallest measured value for each protein column. The user can also assign a shrinking factor to take a fraction of that minimum value for imputation. CAVE: All proteins without any values will be filtered out.",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            },
            "visual_transformation": {
              "name": "Visual transformation:",
              "type": "categorical",
              "categories": [
                "linear",
                "log10"
              ],
              "default": "linear"
            }
          },
          {
            "graph_type_quantities": {
              "name": "Graph type - imputed values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "min_value_per_sample": {
        "name": "Min per sample",
        "description": "Sets missing intensity values to the smallest measured value for each sample",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            },
            "visual_transformation": {
              "name": "Visual transformation:",
              "type": "categorical",
              "categories": [
                "linear",
                "log10"
              ],
              "default": "linear"
            }
          },
          {
            "graph_type_quantities": {
              "name": "Graph type - imputed values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "simple_imputation_per_protein": {
        "name": "SimpleImputer",
        "description": "Imputation methods include imputation by mean, median and mode. Implements the sklearn.SimpleImputer class",
        "parameters": {
          "strategy": {
            "name": "Strategy:",
            "type": "categorical",
            "categories": [
              "mean",
              "median",
              "most_frequent"
            ],
            "default": "mean"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            },
            "visual_transformation": {
              "name": "Visual transformation:",
              "type": "categorical",
              "categories": [
                "linear",
                "log10"
              ],
              "default": "linear"
            }
          },
          {
            "graph_type_quantities": {
              "name": "Graph type - imputed values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "knn": {
        "name": "kNN",
        "description": "A function to perform value imputation based on KNN (k-nearest neighbors). Imputes missing values for each sample based on intensity-wise similar samples. Two samples are close if the features that neither is missing are close.",
        "parameters": {
          "number_of_neighbours": {
            "name": "Number of neighbours:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            },
            "visual_transformation": {
              "name": "Visual transformation:",
              "type": "categorical",
              "categories": [
                "linear",
                "log10"
              ],
              "default": "linear"
            }
          },
          {
            "graph_type_quantities": {
              "name": "Graph type - imputed values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "normal_distribution_sampling": {
        "name": "Normal distribution sampling",
        "description": "Imputation methods include normal distribution sampling per protein or per dataset",
        "parameters": {
          "strategy": {
            "name": "Strategy:",
            "type": "categorical",
            "categories": [
              "perProtein",
              "perDataset"
            ],
            "default": "perProtein"
          },
          "down_shift": {
            "name": "Downshift:",
            "type": "numeric",
            "min": -10,
            "max": 10,
            "default": -1
          },
          "scaling_factor": {
            "name": "Scaling factor:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            },
            "visual_transformation": {
              "name": "Visual transformation:",
              "type": "categorical",
              "categories": [
                "linear",
                "log10"
              ],
              "default": "linear"
            }
          },
          {
            "graph_type_quantities": {
              "name": "Graph type - imputed values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "filter_peptides": {
      "pep_filter": {
        "name": "PEP threshold",
        "description": "Filter by PEP-threshold",
        "parameters": {
          "threshold": {
            "name": "Threshold value for PEP",
            "type": "numeric",
            "min": 0,
            "default": 0
          },
          "peptide_df": {
            "type": "empty",
            "name": "peptide_df"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Bar chart"
            }
          }
        ]
      }
    },
    "output_name": "preprocessed_data"
  },
  "data_analysis": {
    "differential_expression": {
      "anova": {
        "name": "ANOVA",
        "description": "A function that uses ANOVA to test the difference between two or more groups defined in the clinical data. The ANOVA test is conducted on the level of each protein. The p-values are corrected for multiple testing.",
        "parameters": {
          "intensity_df": {
            "name": "Input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple testing correction method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error rate (alpha)",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "log_base": {
            "name": "Base of log transformation",
            "type": "categorical",
            "categories": [
              "None",
              "log2",
              "log10"
            ],
            "default": "log2"
          },
          "grouping": {
            "name": "Grouping:",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "selected_groups"
            ],
            "categories": [],
            "default": "None"
          },
          "selected_groups": {
            "name": "Selected groups (add / remove while holding CTRL-Key):",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": "None",
            "multiple": true,
            "default_select_all": true
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "t_test": {
        "name": "t-Test",
        "description": "A function to conduct a two sample t-test between groups defined in the clinical data. The t-test is conducted on the level of each protein. The p-values are corrected for multiple testing. The fold change is calculated by group2/group1.",
        "parameters": {
          "ttest_type": {
            "name": "t-Test type:",
            "type": "categorical",
            "categories": [
              "Student's t-Test",
              "Welch's t-Test"
            ],
            "default": "Welch's t-Test"
          },
          "intensity_df": {
            "name": "Input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple testing correction method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error rate (alpha)",
            "type": "numeric",
            "min": 0,
            "step": 0.05,
            "max": 1,
            "default": 0.05
          },
          "log_base": {
            "name": "Base of log transformation",
            "type": "categorical",
            "categories": [
              "None",
              "log2",
              "log10"
            ],
            "default": "log2"
          },
          "grouping": {
            "name": "Grouping",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "group1",
              "group2"
            ],
            "categories": [],
            "default": null
          },
          "group1": {
            "name": "Group 1",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "group2": {
            "name": "Group 2",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "linear_model": {
        "name": "Linear model",
        "description": "A function to fit a linear model using ordinary least squares for each protein. The linear model fits the protein intensities on Y axis and the grouping on X for group1 X=-1 and group2 X=1. The p-values are corrected for multiple testing.",
        "parameters": {
          "intensity_df": {
            "name": "Input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple testing correction method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error rate (alpha)",
            "type": "numeric",
            "min": 0,
            "step": 0.05,
            "max": 1,
            "default": 0.05
          },
          "log_base": {
            "name": "Base of log transformation",
            "type": "categorical",
            "categories": [
              "None",
              "log2",
              "log10"
            ],
            "default": "log2"
          },
          "grouping": {
            "name": "Grouping",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "group1",
              "group2"
            ],
            "categories": [],
            "default": null
          },
          "group1": {
            "name": "Group 1",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "group2": {
            "name": "Group 2",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      }
    },
    "plot": {
      "volcano": {
        "name": "Volcano plot",
        "description": "",
        "parameters": {
          "input_dict": {
            "name": "Input data dict (generated by t-Test or Linear Model Diff Exp)",
            "type": "multi_named_output",
            "mapping": {
              "p_values": "corrected_p_values_df",
              "log2_fc": "log2_fold_change_df",
              "alpha": "corrected_alpha",
              "group1": "group1",
              "group2": "group2"
            }
          },
          "fc_threshold": {
            "name": "log2 fold change threshold",
            "type": "numeric",
            "min": 0,
            "default": 0
          },
          "proteins_of_interest_input": {
            "name": "proteins of interest df to highlight in plot",
            "select_from": [
              "input_dict"
            ],
            "type": "named_output_v2",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "proteins_of_interest"
            ]
          },
          "proteins_of_interest": {
            "type": "categorical",
            "fill": "protein_ids",
            "categories": [],
            "default": null,
            "multiple": true
          }
        }
      },
      "scatter_plot": {
        "name": "Scatter plot",
        "description": "Creates a scatter plot from data. This requires a dimension reduction method to be run first, as the input dataframe should contain only 2 or 3 columns.",
        "parameters": {
          "input_df": {
            "name": "Choose dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "color_df": {
            "name": "Choose a dataframe to assign color to marks (optional)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "optional": true
          }
        }
      },
      "clustergram": {
        "name": "Clustergram",
        "description": "Creates a clustergram from data",
        "parameters": {
          "input_df": {
            "name": "Input dataframe: choose dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "sample_group_df": {
            "name": "Grouping dataframe: choose a dataframe that assigns the samples present in the input dataframe to a group they belong (optional)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "optional": true
          },
          "flip_axes": {
            "name": "Do you want to flip the orientation of the heatmap's axes?",
            "type": "categorical",
            "categories": [
              "yes",
              "no"
            ],
            "default": "no"
          }
        }
      },
      "prot_quant": {
        "name": "Prot Quant",
        "description": "Creates a line chart for intensity across samples for proteingroups",
        "parameters": {
          "input_df": {
            "name": "Input dataframe: choose dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "protein_group"
            ]
          },
          "protein_group": {
            "name": "Protein group: choose highlighted protein group",
            "type": "categorical",
            "fill": "protein_ids",
            "categories": [],
            "default": null
          },
          "similarity_measure": {
            "name": "Similarity Measurement: choose how to compare protein groups",
            "type": "categorical",
            "categories": [
              "euclidean distance",
              "cosine similarity"
            ],
            "default": "euclidean_distance"
          },
          "similarity": {
            "name": "Similarity",
            "type": "numeric",
            "min": -1,
            "max": 999,
            "step": 0.1,
            "default": 1
          }
        }
      },
      "precision_recall_curve": {
        "name": "Precision recall curve",
        "description": "The precision-recall curve shows the tradeoff between precision and recall for different threshold",
        "parameters": {
            "input_dict": {
                "name": "Input classification model (generated by Random forest or Support Vector Machine(SVM))",
                "type": "multi_named_output",
                "mapping": {
                  "model": "model",
                  "input_test_df": "X_test_df",
                  "labels_test_df": "y_test_df"
                }
            },
          "plot_title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          }
        }
      },
      "roc_curve": {
        "name": "ROC curve",
        "description": "The ROC curve helps assess the model's ability to discriminate between positive and negative classes and determine an optimal threshold for decision making",
        "parameters": {
          "input_dict": {
            "name": "Input classification model (generated by Random forest or Support Vector Machine(SVM))",
            "type": "multi_named_output",
            "mapping": {
              "model": "model",
              "input_test_df": "X_test_df",
              "labels_test_df": "y_test_df"
            }
          },
          "plot_title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          }
        }
      }
    },
    "clustering": {
      "k_means": {
        "name": "K-means",
        "description": "Partitions a number of samples in k clusters using k-means",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "dynamic": true
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "multiple": true
          },
          "n_clusters": {
            "name": "Number of clusters to find",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 8,
            "multiple": true
          },
          "random_state": {
            "name": "Seed for centroid initialisation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6,
            "multiple": true
          },
          "init_centroid_strategy": {
            "name": "Method for initialisation of centroids",
            "type": "categorical",
            "categories": [
              "k-means++",
              "random"
            ],
            "default": "random",
            "multiple": true
          },
          "n_init": {
            "name": "Number of times the k-means algorithm is run with different centroid seeds",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 10,
            "multiple": true
          },
          "max_iter": {
            "name": "Maximum number of iterations of the k-means algorithm for a single run.",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 300,
            "multiple": true
          },
          "tolerance": {
            "name": "Relative tolerance with regards to Frobenius norm",
            "type": "numeric",
            "min": 0,
            "default": 1e-4,
            "multiple": true
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "expectation_maximisation": {
        "name": "Expectation-maximization (EM) algorithm for fitting mixture-of-Gaussian models",
        "description": "",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "dynamic": true
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "multiple": true
          },
          "n_components": {
            "name": "The number of mixture components",
            "type": "numeric",
            "default": 1,
            "multiple": true
          },
          "reg_covar": {
            "name": "Non-negative regularization added to the diagonal of covariance",
            "type": "numeric",
            "default": 1e-6,
            "multiple": true
          },
          "covariance_type": {
            "name": "Type of covariance",
            "type": "categorical",
            "categories": [
              "full",
              "tied",
              "diag",
              "spherical"
            ],
            "default": "full",
            "multiple": true
          },
          "init_params": {
            "name": "The method used to initialize the weights, the means and the precisions.",
            "type": "categorical",
            "categories": [
              "kmeans",
              "k-means++",
              "random",
              "random_from_data"
            ],
            "default": "kmeans",
            "multiple": true
          },
          "max_iter": {
            "name": "The number of iterations to perform",
            "type": "numeric",
            "default": 100,
            "multiple": true
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "hierarchical_agglomerative_clustering": {
        "name": "Hierarchical agglomerative clustering",
        "description": "Performs hierarchical clustering utilizing a bottom-up approach",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "dynamic": true
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "adjusted_rand_score",
              "completeness_score",
              "fowlkes_mallows_score",
              "homogeneity_score",
              "mutual_info_score",
              "normalized_mutual_info_score",
              "rand_score",
              "v_measure_score"
            ],
            "default": "adjusted_rand_score",
            "multiple": true
          },
          "n_clusters": {
            "name": "Number of clusters to find",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 2,
            "multiple": true
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean",
              "manhattan",
              "cosine",
              "l1",
              "l2"
            ],
            "default": "euclidean",
            "multiple": true
          },
          "linkage": {
            "name": "The linkage criterion to use in order to to determine the distance to use between sets of observation",
            "type": "categorical",
            "categories": [
              "ward",
              "complete",
              "average",
              "single"
            ],
            "default": "ward",
            "multiple": true
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      }
    },
    "classification": {
      "random_forest": {
        "name": "Random forest",
        "description": "A random forest is a meta estimator that fits a number of decision tree classifiers on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "positive_label"
            ],
            "categories": [],
            "default": null
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "test_size": {
            "name": "Test size",
            "type": "numeric",
            "default": 0.20
          },
          "split_stratify": {
            "name": "Split data in a stratified fashion",
            "type": "categorical",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes"
          },
          "validation_strategy": {
            "name": "Validation strategy",
            "type": "categorical_dynamic",
            "categories": [
              "K-Fold",
              "Repeated K-Fold",
              "Stratified K-Fold",
              "Leave one out",
              "Leave p out",
              "Manual"
            ],
            "default": "K-Fold",
            "dynamic_parameters": {
              "K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Stratified K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Repeated K-Fold": [
                "n_splits",
                "n_repeats",
                "random_state_cv"
              ],
              "Leave p out": [
                "p_samples"
              ],
              "Manual": [
                "train_val_split"
              ]
            }
          },
          "train_val_split": {
            "name": "Choose the size of the validation data set (you can either enter the absolute number of validation samples or a number between 0.0 and 1.0 to represent the percentage of validation samples)",
            "type": "numeric",
            "dynamic": true,
            "default": 0.20
          },
          "n_splits": {
            "name": "Number of folds",
            "type": "numeric",
            "min": 2,
            "dynamic": true,
            "default": 5
          },
          "shuffle": {
            "name": "Whether to shuffle the data before splitting into batches",
            "type": "categorical_dynamic",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes",
            "dynamic": true,
            "dynamic_parameters": {
              "yes": [
                "random_state_cv"
              ]
            }
          },
          "n_repeats": {
            "name": "Number of times cross-validator needs to be repeated",
            "type": "numeric",
            "dynamic": true,
            "default": 10
          },
          "random_state_cv": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 42,
            "dynamic": true
          },
          "p_samples": {
            "name": "Size of the test sets",
            "type": "numeric",
            "dynamic": true,
            "default": 1
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "multiple": true
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "dynamic": true
          },
          "n_estimators": {
            "name": "The number of trees in the forest.",
            "type": "numeric",
            "default": 100,
            "multiple": true
          },
          "criterion": {
            "name": "The function to measure the quality of a split",
            "type": "categorical",
            "categories": [
              "gini",
              "log_loss",
              "entropy"
            ],
            "default": "gini",
            "multiple": true
          },
          "max_depth": {
            "name": "The maximum depth of the tree.",
            "type": "numeric",
            "default": 1,
            "multiple": true
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "svm": {
        "name": "Support vector machine (SVM)",
        "description": "",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "labels_column": {
            "name": "Choose labels column from metadata",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "categories": [],
            "default": null
          },
          "test_size": {
            "name": "Test size",
            "type": "numeric",
            "default": 0.20
          },
          "split_stratify": {
            "name": "Split data in a stratified fashion",
            "type": "categorical",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes"
          },
          "positive_label": {
            "name": "Choose positive class",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "validation_strategy": {
            "name": "Validation strategy",
            "type": "categorical_dynamic",
            "categories": [
              "K-Fold",
              "Repeated K-Fold",
              "Stratified K-Fold",
              "Leave one out",
              "Leave p out",
              "Manual"
            ],
            "default": "K-Fold",
            "dynamic_parameters": {
              "K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Stratified K-Fold": [
                "n_splits",
                "shuffle"
              ],
              "Repeated K-Fold": [
                "n_splits",
                "n_repeats",
                "random_state_cv"
              ],
              "Leave p out": [
                "p_samples"
              ],
              "Manual": [
                "test_size"
              ]
            }
          },
          "train_val_split": {
            "name": "Choose the size of the validation data set (you can either enter the absolute number of validation samples or a number between 0.0 and 1.0 to represent the percentage of validation samples)",
            "type": "numeric",
            "dynamic": true,
            "default": 0.20
          },
          "n_splits": {
            "name": "Number of folds",
            "type": "numeric",
            "min": 2,
            "dynamic": true,
            "default": 5
          },
          "shuffle": {
            "name": "Whether to shuffle the data before splitting into batches",
            "type": "categorical_dynamic",
            "categories": [
              "yes",
              "no"
            ],
            "default": "yes",
            "dynamic": true,
            "dynamic_parameters": {
              "True": [
                "random_state_cv"
              ]
            }
          },
          "n_repeats": {
            "name": "Number of times cross-validator needs to be repeated",
            "type": "numeric",
            "dynamic": true,
            "default": 10
          },
          "random_state_cv": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 42,
            "dynamic": true
          },
          "p_samples": {
            "name": "Size of the test sets",
            "type": "numeric",
            "dynamic": true,
            "default": 1
          },
          "scoring": {
            "name": "score",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "multiple": true
          },
          "model_selection": {
            "name": "Choose strategy to perform parameter fine-tuning",
            "type": "categorical_dynamic",
            "categories": [
              "Grid search",
              "Randomized search",
              "Manual"
            ],
            "default": "Grid search",
            "dynamic_parameters": {
              "Grid search": [
                "model_selection_scoring"
              ],
              "Randomized search": [
                "model_selection_scoring"
              ]
            }
          },
          "model_selection_scoring": {
            "name": "Select a scoring for identifying the best estimator following a grid search",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "dynamic": true
          },
          "C": {
            "name": "C: regularization parameter (the strength of the regularization is inversely proportional to C)",
            "type": "numeric",
            "min": 0.0,
            "default": 1.0,
            "multiple": true
          },
          "kernel": {
            "name": "Kernel type",
            "type": "categorical",
            "categories": [
              "linear",
              "poly",
              "rbf",
              "sigmoid",
              "precomputed"
            ],
            "default": "linear",
            "multiple": true
          },
          "tolerance": {
            "name": "Tolerance for stopping criterion",
            "type": "numeric",
            "min": 0,
            "default": 1e-4
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      }
    },
    "model_evaluation": {
      "evaluate_classification_model": {
        "name": "Evaluation of classification models",
        "description": "Assessing an already trained classification model on separate testing data using widely used scoring metrics",
        "parameters": {
          "input_dict": {
            "name": "Input classification model (generated by Random forest or Support Vector Machine(SVM))",
            "type": "multi_named_output",
            "mapping": {
              "model": "model",
              "input_test_df": "X_test_df",
              "labels_test_df": "y_test_df"
            }
          },
          "scoring": {
            "name": "Choose metric to measure the model's performance",
            "type": "categorical",
            "categories": [
              "accuracy",
              "precision",
              "recall",
              "matthews_corrcoef"
            ],
            "default": "accuracy",
            "multiple": true
          }
        }
      }
    },
    "dimension_reduction": {
      "t_sne": {
        "name": "t-SNE",
        "description": "Dimension reduction of a dataframe using t-SNE",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "n_components": {
            "name": "Dimension of the embedded space",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 2
          },
          "perplexity": {
            "name": "Perplexity",
            "type": "numeric",
            "min": 5.0,
            "max": 50.0,
            "default": 30.0
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean",
              "manhattan",
              "cosine",
              "haversine"
            ],
            "default": "euclidean"
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "n_iter": {
            "name": "Maximum number of iterations for the optimization",
            "type": "numeric",
            "min": 250,
            "step": 1,
            "default": 1000
          },
          "n_iter_without_progress": {
            "name": "Maximum number of iterations without progress before aborting the optimization ",
            "type": "numeric",
            "min": 250,
            "step": 1,
            "default": 300
          }
        }
      },
      "umap": {
        "name": "UMAP",
        "description": "Dimension reduction of a dataframe using UMAP",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "n_neighbors": {
            "name": "Number of neighbors",
            "type": "numeric",
            "min": 2,
            "max": 100,
            "step": 1,
            "default": 15
          },
          "n_components": {
            "name": "Number of components",
            "type": "numeric",
            "min": 2,
            "max": 100,
            "step": 1,
            "default": 2
          },
          "min_dist": {
            "name": "The effective minimum distance between embedded points.",
            "type": "numeric",
            "min": 0.1,
            "step": 0.1,
            "default": 0.1
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean",
              "manhattan",
              "cosine",
              "haversine"
            ],
            "default": "euclidean"
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 42
          }
        }
      }
    },
    "protein_graphs": {
      "peptides_to_isoform": {
        "name": "Peptide to isoform",
        "description": "Create a variation graph (.graphml) for a protein and map the peptides onto the graph for coverage visualisation. The protein data will be downloaded from https://rest.uniprot.org/uniprotkb/<Protein ID>.txt. Only `Variant`-features are included in the graph. This, currently, only works with Uniprot-IDs and while you are online.",
        "parameters": {
          "protein_id": {
            "name": "Protein ID",
            "type": "text",
            "default": "",
            "placeholder": "Enter the Uniprot-ID of the protein"
          },
          "run_name": {
            "type": "empty",
            "name": "run_name",
            "default": null
          },
          "peptide_df": {
            "type": "empty",
            "name": "peptide_df",
            "default": null
          },
          "k": {
            "name": "k-mer length",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 5
          },
          "allowed_mismatches": {
            "name": "Number of allowed mismatched amino acids per peptide. For many allowed mismatches, this can take a long time.",
            "type": "numeric",
            "min": 0,
            "step": 1,
            "default": 2
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "condition": "metadata",
            "default": null
          },
          "grouping": {
            "name": "Category by which peptides should be selected.",
            "type": "categorical",
            "condition": "metadata",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "selected_groups"
            ],
            "categories": [],
            "default": "None"
          },
          "selected_groups": {
            "name": "Select group(s) from which peptides should be selected for mapping to the protein graph.",
            "type": "categorical",
            "condition": "metadata",
            "fill": "metadata_column_data",
            "categories": [],
            "default": "None",
            "multiple": true,
            "default_select_all": false
          }
        }
      },
      "variation_graph": {
        "name": "Protein variation graph",
        "description": "Create a variation graph (.graphml) for a protein, including variation-features. The protein data will be downloaded from https://rest.uniprot.org/uniprotkb/<Protein ID>.txt. This, currently, only works with Uniprot-IDs and while you are online.",
        "parameters": {
          "protein_id": {
            "name": "Protein ID",
            "type": "text",
            "default": "",
            "placeholder": "Enter the Uniprot-ID of the protein"
          },
          "run_name": {
            "type": "empty",
            "name": "run_name",
            "default": null
          }
        }
      }
    }
  },
  "data_integration": {
    "enrichment_analysis": {
      "GO_analysis_with_STRING": {
        "name": "GO analysis with STRING",
        "description": "Online GO analysis using STRING API",
        "parameters": {
          "proteins_df": {
            "name": "Dataframe with protein IDs and direction of expression change column (e.g. log2FC)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "differential_expression_col"
            ]
          },
          "differential_expression_col": {
            "name": "Column name with differential expression values indicating direction of change",
            "type": "categorical",
            "fill": "protein_df_columns",
            "default": null
          },
          "differential_expression_threshold": {
            "name": "Threshold for differential expression: Proteins with values > threshold are upregulated, proteins values < threshold downregulated. If \"log\" is in the name of differential_expression_col, threshold is applied symmetrically: e.g. log2_fold_change > threshold is upregulated, if log2_fold_change < -threshold downregulated",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "default": 0
          },
          "gene_sets_restring": {
            "name": "Knowledge bases for enrichment",
            "type": "categorical",
            "fill": "dbs_restring",
            "categories": [],
            "default": null,
            "multiple": true
          },
          "organism": {
            "name": "Organism / NCBI taxon identifiers (e.g. Human is 9606)",
            "type": "numeric",
            "default": 9606
          },
          "direction": {
            "name": "Direction of the analysis",
            "type": "categorical",
            "categories": [
              "both",
              "up",
              "down"
            ],
            "default": "both"
          },
          "background_path": {
            "name": "Background set (no upload = entire proteome), UniProt IDs (one per line, txt or csv)",
            "type": "file",
            "default": null
          }
        }
      },
      "GO_analysis_with_Enrichr": {
        "name": "GO analysis with Enrichr",
        "description": "Online GO analysis using Enrichr API",
        "parameters": {
          "proteins_df": {
            "name": "Dataframe with protein IDs and direction of expression change column (e.g. log2FC)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "differential_expression_col"
            ]
          },
          "differential_expression_col": {
            "name": "Column name with differential expression values indicating direction of change",
            "type": "categorical",
            "fill": "protein_df_columns",
            "default": null
          },
          "differential_expression_threshold": {
            "name": "Threshold for differential expression: proteins with values > threshold are upregulated, proteins values < threshold downregulated. If \"log\" is in the name of differential_expression_col, threshold is applied symmetrically: e.g. log2_fold_change > threshold is upregulated, if log2_fold_change < -threshold downregulated",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "default": 0
          },
          "gene_mapping": {
            "name": "Gene mapping",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "gene_sets_field": {
            "name": "How do you want to provide the gene sets? (reselect to show dynamic fields)",
            "type": "categorical_dynamic",
            "categories": [
              "Upload a file",
              "Choose from Enrichr Options"
            ],
            "default": "Choose from Enrichr Options",
            "dynamic_parameters": {
              "Upload a file": [
                "gene_sets_path"
              ],
              "Choose from Enrichr Options": [
                "gene_sets_enrichr"
              ]
            }
          },
          "gene_sets_path": {
            "name": "Upload gene sets with uppercase gene symbols (any of the following file types: .gmt, .txt, .csv, .json | .txt (one set per line): SetName followed by tab-separated list of proteins | .csv (one set per line): SetName, Gene1, Gene2, ... | .json: {SetName: [Gene1, Gene2, ...], SetName2: [Gene2, Gene3, ...]})",
            "type": "file",
            "default": null,
            "dynamic": true
          },
          "gene_sets_enrichr": {
            "name": "Gene set libraries",
            "type": "categorical",
            "fill": "dbs_gseapy",
            "categories": [],
            "default": null,
            "multiple": true,
            "dynamic": true
          },
          "direction": {
            "name": "Direction of the analysis",
            "type": "categorical",
            "categories": [
              "both",
              "up",
              "down"
            ],
            "default": "both"
          },
          "organism": {
            "name": "Enrichr supported organism",
            "type": "categorical",
            "categories": [
              "human",
              "mouse",
              "yeast",
              "fly",
              "fish",
              "worm"
            ],
            "default": "human"
          },
          "background_field": {
            "name": "How do you want to provide the background set? This parameter works only for uploaded gene sets and will otherwise be ignored!",
            "type": "categorical_dynamic",
            "categories": [
              "Upload a file (recommended)",
              "Choose biomart dataset",
              "Specify number of expressed genes (not recommended)",
              "Use all genes in the gene sets"
            ],
            "default": "Upload a file (recommended)",
            "dynamic_parameters": {
              "Upload a file (recommended)": [
                "background_path"
              ],
              "Specify number of expressed genes (not recommended)": [
                "background_number"
              ],
              "Choose biomart dataset": [
                "background_biomart"
              ]
            }
          },
          "background_path": {
            "name": "Background set with uppercase gene symbols (one gene per line, csv or txt)",
            "type": "file",
            "default": null,
            "dynamic": true
          },
          "background_number": {
            "name": "Number of expressed genes",
            "type": "numeric",
            "min": 1,
            "max": 4294967295,
            "step": 1,
            "default": null,
            "dynamic": true
          },
          "background_biomart": {
            "name": "Biomart dataset",
            "type": "categorical",
            "fill": "biomart_datasets",
            "categories": [],
            "default": null,
            "dynamic": true
          }
        }
      },
      "GO_analysis_offline": {
        "name": "GO analysis offline",
        "description": "Offline GO Analysis using a hypergeometric test",
        "parameters": {
          "proteins_df": {
            "name": "Dataframe with protein IDs and direction of expression change column (e.g. log2FC)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "differential_expression_col"
            ]
          },
          "differential_expression_col": {
            "name": "Column name with differential expression values indicating direction of change",
            "type": "categorical",
            "fill": "protein_df_columns",
            "default": null
          },
          "differential_expression_threshold": {
            "name": "Threshold for differential expression: proteins with values > threshold are upregulated, proteins values < threshold downregulated. If \"log\" is in the name of differential_expression_col, threshold is applied symmetrically: e.g. log2_fold_change > threshold is upregulated, if log2_fold_change < -threshold downregulated",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "default": 0
          },
          "gene_mapping": {
            "name": "Gene mapping",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "gene_sets_path": {
            "name": "Upload gene sets with uppercase gene symbols (any of the following file types: .gmt, .txt, .csv, .json | .txt (one set per line): SetName followed by tab-separated list of proteins | .csv (one set per line): SetName, Gene1, Gene2, ... | .json: {SetName: [Gene1, Gene2, ...], SetName2: [Gene2, Gene3, ...]})",
            "type": "file",
            "default": null
          },
          "direction": {
            "name": "Direction of the analysis",
            "type": "categorical",
            "categories": [
              "both",
              "up",
              "down"
            ],
            "default": "both"
          },
          "background_field": {
            "name": "How do you want to provide the background set? This parameter works only for uploaded gene sets and will otherwise be ignored!",
            "type": "categorical_dynamic",
            "categories": [
              "Upload a file (recommended)",
              "Specify number of expressed genes (not recommended)",
              "Use all genes in the gene sets"
            ],
            "default": "Upload a file (recommended)",
            "dynamic_parameters": {
              "Upload a file (recommended)": [
                "background_path"
              ],
              "Specify number of expressed genes (not recommended)": [
                "background_number"
              ]
            }
          },
          "background_path": {
            "name": "Background set with uppercase gene symbols (one protein per line, csv or txt)",
            "type": "file",
            "default": null,
            "dynamic": true
          },
          "background_number": {
            "name": "Number of expressed genes",
            "type": "numeric",
            "min": 1,
            "max": 4294967295,
            "step": 1,
            "default": null,
            "dynamic": true
          }
        }
      },
      "gsea": {
        "name": "GSEA",
        "description": "Perform gene set enrichment analysis",
        "parameters": {
          "protein_df": {
            "name": "Dataframe with protein IDs, samples and intensities",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "gene_mapping": {
            "name": "Gene mapping",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "gene_sets_field": {
            "name": "How do you want to provide the gene sets? (reselect to show dynamic fields)",
            "type": "categorical_dynamic",
            "categories": [
              "Upload a file",
              "Choose from Enrichr Options"
            ],
            "default": "Choose from Enrichr Options",
            "dynamic_parameters": {
              "Upload a file": [
                "gene_sets_path"
              ],
              "Choose from Enrichr Options": [
                "gene_sets_enrichr"
              ]
            }
          },
          "gene_sets_path": {
            "name": "Upload Gene Sets with uppercase gene symbols (any of the following file types: .gmt, .txt, .csv, .json | .txt (one set per line): SetName followed by tab-separated list of proteins | .csv (one set per line): SetName, Gene1, Gene2, ... | .json: {SetName: [Gene1, Gene2, ...], SetName2: [Gene2, Gene3, ...]})",
            "type": "file",
            "default": null,
            "dynamic": true
          },
          "gene_sets_enrichr": {
            "name": "Gene sets",
            "type": "categorical",
            "fill": "dbs_gseapy",
            "categories": [],
            "default": null,
            "multiple": true,
            "dynamic": true
          },
          "grouping": {
            "name": "Grouping from metadata",
            "type": "categorical",
            "fill": "metadata_non_sample_columns",
            "fill_dynamic": [
              "group1",
              "group2"
            ],
            "categories": [],
            "default": null
          },
          "group1": {
            "name": "Group 1",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "group2": {
            "name": "Group 2",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "min_size": {
            "name": "Minimum number of genes from gene set also in data",
            "type": "numeric",
            "default": 15
          },
          "max_size": {
            "name": "Maximum number of genes from gene set also in data",
            "type": "numeric",
            "default": 500
          },
          "number_of_permutations": {
            "name": "Number of permutations",
            "type": "numeric",
            "default": 1000
          },
          "permutation_type": {
            "name": "Permutation type (if samples >=15 set to phenotype)",
            "type": "categorical",
            "categories": [
              "phenotype",
              "gene_set"
            ],
            "default": "phenotype"
          },
          "ranking_method": {
            "name": "Method to calculate correlation or ranking",
            "type": "categorical",
            "categories": [
              "log2_ratio_of_classes",
              "signal_to_noise",
              "t_test",
              "ratio_of_classes",
              "diff_of_classes"
            ],
            "default": "signal_to_noise"
          },
          "weighted_score": {
            "name": "Weighted score for the enrichment score calculation, recommended values: 0, 1, 1.5 or 2",
            "type": "numeric",
            "default": 1
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "gsea_preranked": {
        "name": "GSEA preranked",
        "description": "Maps proteins to genes and performs GSEA according using provided numerical column for ranking",
        "parameters": {
          "protein_df": {
            "name": "Dataframe with protein IDs and a column to use for ranking (e.g. p values)",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "ranking_column"
            ]
          },
          "ranking_column": {
            "name": "Column to use for ranking",
            "type": "categorical",
            "fill": "protein_df_columns",
            "categories": [],
            "default": null
          },
          "ranking_direction": {
            "name": "Sort the ranking column (ascending - smaller values are better, descending - larger values are better)",
            "type": "categorical",
            "categories": [
              "ascending",
              "descending"
            ],
            "default": "ascending"
          },
          "gene_mapping": {
            "name": "Gene mapping",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "gene_sets_field": {
            "name": "How do you want to provide the gene sets? (reselect to show dynamic fields)",
            "type": "categorical_dynamic",
            "categories": [
              "Upload a file",
              "Choose from Enrichr Options"
            ],
            "default": "Choose from Enrichr Options",
            "dynamic_parameters": {
              "Upload a file": [
                "gene_sets_path"
              ],
              "Choose from Enrichr Options": [
                "gene_sets_enrichr"
              ]
            }
          },
          "gene_sets_path": {
            "name": "Upload gene sets with uppercase gene symbols (any of the following file types: .gmt, .txt, .csv, .json | .txt (one set per line): SetName followed by tab-separated list of proteins | .csv (one set per line): SetName, Gene1, Gene2, ... | .json: {SetName: [Gene1, Gene2, ...], SetName2: [Gene2, Gene3, ...]})",
            "type": "file",
            "default": null,
            "dynamic": true
          },
          "gene_sets_enrichr": {
            "name": "Gene set libraries",
            "type": "categorical",
            "fill": "dbs_gseapy",
            "categories": [],
            "default": null,
            "multiple": true,
            "dynamic": true
          },
          "min_size": {
            "name": "Minimum number of genes from gene set also in data",
            "type": "numeric",
            "default": 15
          },
          "max_size": {
            "name": "Maximum number of genes from gene set also in data",
            "type": "numeric",
            "default": 500
          },
          "number_of_permutations": {
            "name": "Number of permutations",
            "type": "numeric",
            "default": 1000
          },
          "permutation_type": {
            "name": "Permutation type (if samples >=15 set to phenotype)",
            "type": "categorical",
            "categories": [
              "phenotype",
              "gene_set"
            ],
            "default": "phenotype"
          },
          "weighted_score": {
            "name": "Weighted score for the enrichment score calculation, recommended values: 0, 1, 1.5 or 2",
            "type": "numeric",
            "default": 1
          }
        }
      }
    },
    "database_integration": {
      "gene_mapping": {
        "name": "Gene mapping",
        "description": "Map protein groups to genes",
        "parameters": {
          "dataframe": {
            "name": "Dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "database_names": {
            "name": "Uniprot databases (offline)",
            "type": "categorical",
            "multiple": true,
            "fill": "uniprot_databases"
          },
          "use_biomart": {
            "name": "Use Biomart after Uniprot databases (online)",
            "type": "boolean",
            "default": false
          }
        }
      },
      "uniprot": {
        "name": "Uniprot",
        "description": "Add Uniprot data to a dataframe",
        "parameters": {
          "dataframe": {
            "name": "Dataframe",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "database_name": {
            "name": "Database name",
            "type": "categorical",
            "fill": "uniprot_databases",
            "fill_dynamic": [
              "fields"
            ]
          },
          "fields": {
            "name": "Fields",
            "type": "categorical",
            "multiple": true,
            "fill": "uniprot_fields"
          }
        }
      }
    },
    "plot": {
      "GO_enrichment_bar_plot": {
        "name": "Bar plot for GO enrichment analysis",
        "description": "Creates a bar plot from GO enrichment data",
        "parameters": {
          "input_df": {
            "name": "Choose dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "gene_sets"
            ]
          },
          "gene_sets": {
            "name": "Sets to be plotted",
            "type": "categorical",
            "multiple": true,
            "fill": "enrichment_categories"
          },
          "value": {
            "name": "Value (bars will be plotted as -log10(value)), fdr only for GO analysis with STRING, p_value is adjusted if available",
            "type": "categorical",
            "categories": [
              "p_value",
              "fdr"
            ],
            "default": "p_value"
          },
          "top_terms": {
            "name": "Number of top enriched terms per category",
            "type": "numeric",
            "min": 1,
            "max": 100,
            "step": 1,
            "default": 10
          },
          "cutoff": {
            "name": "Only terms with adjusted p-value (or FDR) < cutoff will be shown",
            "type": "numeric",
            "min": 0,
            "step": 0.01,
            "max": 1,
            "default": 0.05
          },
          "title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          },
          "colors": {
            "name": "Colors for the plot (optional)",
            "type": "categorical",
            "multiple": true,
            "fill": "matplotlib_colors",
            "default": null
          }
        }
      },
      "GO_enrichment_dot_plot": {
        "name": "Dot plot for GO enrichment analysis (offline & with Enrichr) ",
        "description": "Creates a categorical scatter plot from GO enrichment data",
        "parameters": {
          "input_df": {
            "name": "Choose enrichment dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "gene_sets"
            ]
          },
          "x_axis_type": {
            "name": "Variable for x-axis: categorical scatter plot for one or multiple gene sets, or display combined score for one gene set",
            "type": "categorical",
            "categories": [
              "Gene Sets",
              "Combined Score"
            ],
            "default": "Gene Sets"
          },
          "gene_sets": {
            "name": "Sets to be plotted (if this is empty, try reselecting the enrichment dataframe from your chosen input)",
            "type": "categorical",
            "multiple": true,
            "fill": "enrichment_categories"
          },
          "top_terms": {
            "name": "Number of top enriched terms per category",
            "type": "numeric",
            "min": 1,
            "max": 100,
            "step": 1,
            "default": 5
          },
          "cutoff": {
            "name": "Only terms with adjusted p-value < cutoff will be shown",
            "type": "numeric",
            "min": 0,
            "step": 0.01,
            "max": 1,
            "default": 0.05
          },
          "title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          },
          "rotate_x_labels": {
            "name": "Rotate x-axis labels (if multiple categories are selected)",
            "type": "boolean",
            "default": true
          },
          "show_ring": {
            "name": "Show ring around the dots",
            "type": "boolean",
            "default": false
          },
          "dot_size": {
            "name": "Scale the size of the dots",
            "type": "numeric",
            "default": 5
          }
        }
      },
      "gsea_dot_plot": {
        "name": "Dot plot for (pre-ranked) GSEA",
        "description": "Creates a categorical scatter plot from GSEA data",
        "parameters": {
          "input_df": {
            "name": "Choose enrichment dataframe to be plotted",
            "type": "named_output",
            "default": [
              null,
              null
            ],
            "fill_dynamic": [
              "gene_sets"
            ]
          },
          "gene_sets": {
            "name": "Gene sets/libraries to be plotted (if this is empty, try reselecting the input enrichment dataframe from your chosen input)",
            "type": "categorical",
            "multiple": true,
            "fill": "gsea_enrichment_categories"
          },
          "dot_color_value": {
            "name": "Color the dots by value",
            "type": "categorical",
            "categories": [
              "FDR q-val",
              "NOM p-val"
            ],
            "default": "FDR q-val"
          },
          "x_axis_value": {
            "name": "Value to display on x axis",
            "type": "categorical",
            "categories": [
              "ES",
              "NES"
            ],
            "default": "NES"
          },
          "cutoff": {
            "name": "Cutoff value for fdr q-value or nominal p-value",
            "type": "numeric",
            "min": 0,
            "step": 0.01,
            "max": 1,
            "default": 0.05
          },
          "title": {
            "name": "Title of the plot (optional)",
            "type": "text"
          },
          "dot_size": {
            "name": "Scale the size of the dots",
            "type": "numeric",
            "default": 5
          },
          "show_ring": {
            "name": "Show ring around the dots",
            "type": "boolean",
            "default": false
          },
          "remove_library_names": {
            "name": "Remove library names from gene sets (e.g. 'KEGG_2013__')",
            "type": "boolean",
            "default": false
          }
        }
      },
      "gsea_enrichment_plot": {
        "name": "Enrichment plot for (pre-ranked) GSEA",
        "description": "Creates an enrichment plot from (pre-ranked) GSEA data with the enrichment score, ranked_metric, gene rank and hits",
        "parameters": {
          "term_dict": {
            "name": "Enrichment details gene set to be plotted",
            "type": "named_output",
            "sorted": true,
            "default": [
              null,
              null
            ]
          },
          "term_name": {
            "name": "name of the term_dict for title",
            "type": "empty",
            "default": null
          },
          "ranking": {
            "name": "Ranking from GSEA",
            "type": "named_output",
            "default": [
              null,
              null
            ]
          },
          "pos_pheno_label": {
            "name": "Label for positively correlated phenotype",
            "type": "text",
            "default": ""
          },
          "neg_pheno_label": {
            "name": "Label for negatively correlated phenotype",
            "type": "text",
            "default": ""
          }
        }
      }
    }
  }
}
