{
  "importing": {
    "ms_data_import": {
      "max_quant_import": {
        "name": "Max Quant",
        "description": "Max Quant Data Import",
        "parameters": {
          "file_path": {
            "name": "MaxQuant intensities file:",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "intensity parameter",
            "type": "categorical",
            "categories": [
              "LFQ intensity",
              "Intensity",
              "iBAQ"
            ],
            "default": "Intensity"
          }
        }
      },
      "ms_fragger_import": {
        "name": "MS Fragger",
        "description": "MS Fragger Data Import",
        "parameters": {
          "file_path": {
            "name": "MSFragger intensities file:",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "intensity name",
            "type": "categorical",
            "categories": [
              "Intensity",
              "MaxLFQ Total Intensity",
              "MaxLFQ Intensity",
              "Total Intensity",
              "MaxLFQ Unique Intensity",
              "Unique Spectral Count",
              "Unique Intensity",
              "Spectral Count",
              "Total Spectral Count"
            ],
            "default": "Intensity"
          }
        }
      }
    },
    "metadata_import": {
      "metadata_import_method": {
        "name": "Metadata Import",
        "description": "Import Metadata",
        "parameters": {
          "file_path": {
            "name": "Metadata file:",
            "type": "file",
            "default": null
          },
          "feature_orientation": {
            "name": "feature orientation",
            "type": "categorical",
            "categories": [
              "Rows (features in rows, samples in columns)",
              "Columns (samples in rows, features in columns)"
            ],
            "default": "Columns (samples in rows, features in columns)"
          }
        }
      }
    },
    "peptide_import": {
      "peptide_import": {
        "name": "Peptide Import",
        "description": "Import Peptide-Data",
        "parameters": {
          "file_path": {
            "name": "Peptide File",
            "type": "file",
            "default": null
          },
          "intensity_name": {
            "name": "Intensity Parameter (same as MS-Data)",
            "type": "categorical",
            "categories": [
              "LFQ intensity",
              "Intensity",
              "iBAQ"
            ],
            "default": "Intensity"
          }
        }
      }
    }
  },
  "data_preprocessing": {
    "filter_proteins": {
      "low_frequency_filter": {
        "name": "Low Frequency",
        "description": "This function filters proteins with a low frequency of occurrence from a protein dataframe based on a set threshold. The threshold is defined by the relative amount of samples a protein is detected in.",
        "parameters": {
          "threshold": {
            "name": "Threshold for the relative amount of samples a protein is detected in:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Bar chart"
            }
          }
        ]
      }
    },
    "filter_samples": {
      "protein_count_filter": {
        "name": "Protein Count",
        "description": "Filter by protein count per sample",
        "parameters": {
          "threshold": {
            "name": "Number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "proteins_missing_filter": {
        "name": "Proteins Missing",
        "description": "Filters all samples that contain less than a set percentage of proteins",
        "parameters": {
          "percentage": {
            "name": "Percentage of minimum non-missing proteins per sample",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "protein_intensity_sum_filter": {
        "name": "Sum of Intensities",
        "description": "Filter by sum of protein intensities per sample",
        "parameters": {
          "threshold": {
            "name": "Number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "outlier_detection": {
      "pca": {
        "name": "PCA",
        "description": "This function filters out outliers using a PCA based approach based geometrical distance to the median and returns a list of samples that are inliers. Allows 2D (using an ellipse) or 3D (using an ellipsoid) analysis.",
        "parameters": {
          "threshold": {
            "name": "Threshold for number of standard deviations from the median:",
            "type": "numeric",
            "min": 0,
            "default": 2
          },
          "number_of_components": {
            "name": "Number of components:",
            "type": "numeric",
            "min": 2,
            "max": 3,
            "step": 1,
            "default": 3
          }
        },
        "graphs": [
          {}
        ]
      },
      "isolation_forest": {
        "name": "Isolation Forest",
        "description": "This function filters out outliers using a clustering isolation forest approach.",
        "parameters": {
          "n_estimators": {
            "name": "Number of estimators:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 100
          }
        },
        "graphs": [
          {}
        ]
      },
      "local_outlier_factor": {
        "name": "Local Outlier Factor",
        "description": "This function filters out outliers using a clustering Local Outlier Factor approach based on k nearest neighbors clustering.",
        "parameters": {
          "number_of_neighbors": {
            "name": "Number of neighbours:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 20
          }
        },
        "graphs": [
          {}
        ]
      }
    },
    "transformation": {
      "log_transformation": {
        "name": "Log",
        "description": "This function log-transforms intensity DataFrames. Supports log-transformation to the base of 2 or 10.",
        "parameters": {
          "log_base": {
            "name": "Log transformation base:",
            "type": "categorical",
            "categories": [
              "log2",
              "log10"
            ],
            "default": "log2"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      }
    },
    "normalisation": {
      "z_score": {
        "name": "Z-Score",
        "description": "A function to run the sklearn StandardScaler class on your dataframe. Normalises the data on the level of each sample. Scales the data to zero mean and unit variance. This is often also called z-score normalisation/ transformation.",
        "parameters": {},
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "totalsum": {
        "name": "Total Sum",
        "description": "A function to perform normalisation using the total sum of sample intensities on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the total sum of sample intensities.",
        "parameters": {},
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "median": {
        "name": "Median",
        "description": "A function to perform a quartile/percentile normalisation on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the chosen intensity quartile of the respective sample. By default, the median (50%-quartile) is used.",
        "parameters": {
          "percentile": {
            "name": "Percentile for normalisation:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      },
      "ref_protein": {
        "name": "Protein Reference",
        "description": "A function to perform protein-intensity normalisation in reference to a selected protein on your dataframe. Normalises the data on the level of each sample. Divides each intensity by the intensity of the chosen reference protein in each sample. Samples where this value is zero will be removed and returned separately.",
        "parameters": {
          "reference_protein": {
            "name": "Reference Protein:",
            "type": "text",
            "default": "",
            "placeholder": "Enter the protein ID for the reference protein"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          }
        ]
      }
    },
    "imputation": {
      "min_value_per_dataset": {
        "name": "Min per Dataset",
        "description": "A function to impute missing values for each protein by taking into account data from the entire dataframe. Sets missing value to the smallest measured value in the dataframe. The user can also assign a shrinking factor to take a fraction of that minimum value for imputation.",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking Value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "min_value_per_protein": {
        "name": "Min per Protein",
        "description": "A function to impute missing values for each protein by taking into account data from each protein. Sets missing value to the smallest measured value for each protein column. The user can also assign a shrinking factor to take a fraction of that minimum value for imputation. CAVE: All proteins without any values will be filtered out.",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking Value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "min_value_per_sample": {
        "name": "Min per Sample",
        "description": "Sets missing intensity values to the smallest measured value for each sample",
        "parameters": {
          "shrinking_value": {
            "name": "Shrinking Value:",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 1
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "simple_imputation_per_protein": {
        "name": "SimpleImputer",
        "description": "Imputation methods include imputation by mean, median and mode. Implements the sklearn.SimpleImputer class",
        "parameters": {
          "strategy": {
            "name": "Strategy:",
            "type": "categorical",
            "categories": [
              "mean",
              "median",
              "most_frequent"
            ],
            "default": "mean"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      },
      "knn": {
        "name": "kNN",
        "description": "A function to perform value imputation based on KNN (k-nearest neighbors). Imputes missing values for each sample based on intensity-wise similar samples. Two samples are close if the features that neither is missing are close.",
        "parameters": {
          "number_of_neighbours": {
            "name": "Number of neighbours:",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 5
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Boxplot",
                "Histogram"
              ],
              "default": "Boxplot"
            },
            "group_by": {
              "name": "Group by:",
              "type": "categorical",
              "categories": [
                "None",
                "Sample",
                "Protein ID"
              ],
              "default": "None"
            }
          },
          {
            "graph_type_quantites": {
              "name": "Graph type â€“ Imputed Values:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Pie chart"
            }
          }
        ]
      }
    },
    "filter_peptides": {
      "pep_filter": {
        "name": "PEP Threshold",
        "description": "Filter by PEP-Threshold",
        "parameters": {
          "threshold": {
            "name": "Threshold Value for PEP",
            "type": "numeric",
            "min": 0,
            "default": 0
          },
          "peptide_df": {
            "type": "empty",
            "name": "peptide_df"
          }
        },
        "graphs": [
          {
            "graph_type": {
              "name": "Graph type:",
              "type": "categorical",
              "categories": [
                "Bar chart",
                "Pie chart"
              ],
              "default": "Bar chart"
            }
          }
        ]
      }
    }
  },
  "data_analysis": {
    "differential_expression": {
      "anova": {
        "name": "ANOVA",
        "description": "A function that uses ANOVA to test the difference between two or more groups defined in the clinical data. The ANOVA test is conducted on the level of each protein. The p-values are corrected for multiple testing.",
        "parameters": {
          "intensity_df": {
            "name": "Input Dataframe",
            "type": "named_output",
            "default": [null, null]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple Testing Correction Method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error Rate (alpha)",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "grouping": {
            "name": "Grouping:",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "selected_groups"
            ],
            "categories": [],
            "default": "None"
          },
          "selected_groups": {
            "name": "Selected Groups:",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": "None",
            "multiple": true,
            "default_select_all": true
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      },
      "t_test": {
        "name": "t-Test",
        "description": "A function to conduct a two sample t-test between groups defined in the clinical data. The t-test is conducted on the level of each protein. The p-values are corrected for multiple testing.",
        "parameters": {
          "intensity_df": {
            "name": "Input Dataframe",
            "type": "named_output",
            "default": [null, null]
          },
          "multiple_testing_correction_method": {
            "name": "Multiple Testing Correction Method:",
            "type": "categorical",
            "categories": [
              "Benjamini-Hochberg",
              "Bonferroni"
            ],
            "default": "Benjamini-Hochberg"
          },
          "alpha": {
            "name": "Error Rate (alpha)",
            "type": "numeric",
            "min": 0,
            "max": 1,
            "default": 0.05
          },
          "fc_threshold": {
            "name": "Fold change threshold",
            "type": "numeric",
            "min": 0,
            "default": 0
          },
          "grouping": {
            "name": "Grouping",
            "type": "categorical",
            "fill": "metadata_columns",
            "fill_dynamic": [
              "group1",
              "group2"
            ],
            "categories": [],
            "default": null
          },
          "group1": {
            "name": "Group 1",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "group2": {
            "name": "Group 2",
            "type": "categorical",
            "fill": "metadata_column_data",
            "categories": [],
            "default": null
          },
          "metadata_df": {
            "type": "empty",
            "name": "metadata_df",
            "default": null
          }
        }
      }
    },
    "plot": {
      "volcano": {
        "name": "Volcano Plot",
        "description": "",
        "parameters": {
          "p_values": {
            "name": "p-value df",
            "type": "named_output",
            "default": [null, null]
          },
          "log2_fc": {
            "name": "log2 fold change df",
            "type": "named_output",
            "default": [null, null]
          },
          "fc_threshold": {
            "name": "log2 fold change threshold",
            "type": "named_output",
            "default": [null, null]
          },
          "alpha": {
            "name": "alpha/corrected alpha",
            "type": "named_output",
            "default": [null, null]
          },
          "proteins_of_interest_wrapper": {
            "name": "Proteins of Interest",
            "type": "named_output_with_fields",
            "fill_dynamic": ["proteins_of_interest"],
            "default": [null, null, null],
            "fields": {
              "proteins_of_interest": {
                "type": "categorical",
                "fill": "protein_ids",
                "categories": [],
                "default": null,
                "multiple": true
              }
            }
          }
        }
      },
      "heatmap": {
        "name": "Heatmap",
        "description": "",
        "parameters": {
        }
      },
      "scatter_plot": {
        "name": "Scatter plot",
        "description":"Creates a scatter plot from data",
        "parameters": {
          "input_df": {
            "name": "Choose dataframe to be plotted",
            "type": "named_output",
            "default": [null, null]
          },
          "color_df": {
            "name": "Choose a dataframe to assign color to marks (optional)",
            "type": "named_output",
            "default": [null, null],
            "optional": true
          }
        }
      },
      "clustergram": {
        "name": "Clustergram",
        "description":"Creates a clustergram from data",
        "parameters": {
          "input_df": {
            "name": "Input dataframe: choose dataframe to be plotted",
            "type": "named_output",
            "default": [null, null]
          },
          "sample_group_df": {
            "name": "Grouping dataframe: choose a dataframe that assigns the samples present in the input dataframe to a group they belong (optional)",
            "type": "named_output",
            "default": [null, null],
            "optional": true
          },
          "flip_axes": {
            "name": "Do you want to flip the orientation of the heatmap's axes?",
            "type": "categorical",
            "categories": ["yes", "no"],
            "default": "no"
          }
        }
      }
    },
    "clustering": {
      "k_means": {
        "name": "K-Means",
        "description": "Partitions a number of samples in k clusters using k-means",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [null, null]
          },
          "n_clusters": {
            "name": "Number of clusters to form",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 8
          },
          "random_state": {
            "name": "Seed for centroid initialisation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "init_centroid_strategy": {
            "name": "Method for initialisation of centroids",
            "type":"categorical",
            "categories": [
              "k-means++",
              "random"
            ],
            "default": "random"
          },
          "n_init": {
            "name": "Number of times the k-means algorithm is run with different centroid seeds",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 10
          },
          "max_iter": {
            "name": "Maximum number of iterations of the k-means algorithm for a single run.",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 300
          },
          "tolerance": {
            "name": "Relative tolerance with regards to Frobenius norm",
            "type": "numeric",
            "min": 0,
            "default": 1e-4
          }
        }
      }
    },
    "dimension_reduction": {
      "t_sne": {
        "name": "t-SNE",
        "description": "Dimension reduction of a dataframe using t-SNE",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [null, null]
          },
          "n_components": {
            "name": "Dimension of the embedded space",
            "type": "numeric",
            "min": 1,
            "step": 1,
            "default": 2
          },
          "perplexity": {
            "name": "Perplexity",
            "type": "numeric",
            "min": 5.0,
            "max": 50.0,
            "default": 30.0
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean","manhattan","cosine", "haversine"
            ],
            "default": "euclidean"
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 6
          },
          "n_iter": {
            "name": "Maximum number of iterations for the optimization",
            "type": "numeric",
            "min": 250,
            "step": 1,
            "default": 1000
          },
          "n_iter_without_progress": {
            "name": "Maximum number of iterations without progress before aborting the optimization ",
            "type": "numeric",
            "min": 250,
            "step": 1,
            "default": 300
          }
        }
      },
      "umap": {
        "name": "UMAP",
        "description":"Dimension reduction of a dataframe using UMAP",
        "parameters": {
          "input_df": {
            "name": "Choose input dataframe",
            "type": "named_output",
            "default": [null, null]
          },
          "n_neighbors": {
            "name": "Number of neighbors",
            "type": "numeric",
            "min": 2,
            "max": 100,
            "step": 1,
            "default": 15
          },
          "n_components": {
            "name": "Number of components",
            "type": "numeric",
            "min": 2,
            "max": 100,
            "step": 1,
            "default": 2
          },
          "min_dist": {
            "name": "The effective minimum distance between embedded points.",
            "type": "numeric",
            "min": 0.1,
            "default": 0.1
          },
          "metric": {
            "name": "Distance metric",
            "type": "categorical",
            "categories": [
              "euclidean","manhattan","cosine", "haversine"
            ],
            "default": "euclidean"
          },
          "random_state": {
            "name": "Seed for random number generation",
            "type": "numeric",
            "min": 0,
            "max": 4294967295,
            "step": 1,
            "default": 42
          }
        }
      }
    }
  },
  "data_integration": {  
    "enrichment_analysis": {
      "go_analysis_with_enrichr": {
        "name": "GO Analysis with enrichr",
        "description": "Online GO Analysis using Enrichr API",
        "parameters": {
          "proteins": {
            "name": "Choose Proteins to run GO Analysis on",
            "type": "named_output",
            "default": [null,null]
          },
          "protein_sets": {
            "name": "Protein Sets",
            "type": "categorical",
            "fill": "dbs_gseapy",
            "categories": [],
            "default": null,
            "multiple": true
          },
          "organism": {
            "name": "Enrichr supported organism",
            "type": "categorical",
            "categories": ["human", "mouse", "yeast", "fly", "fish", "worm"],
            "default": "human"
          }
        }
      }
    }
  }
}
